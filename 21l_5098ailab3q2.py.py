# -*- coding: utf-8 -*-
"""21L-5098AIlab3Q2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GrhALAiL3B3S0zc1JA-6Y_DjU0qqiLHk
"""

# question2 dfs of 8 puzzle
import time

def state_to_tuple(state):
    # covert a string state to a tuple representation
    matrix = []
    for i in range(0, 9, 3):
        row = list(state[i:i+3])
        matrix.append(row)
    return tuple(tuple(row) for row in matrix)

def tuple_to_state(matrix):
    # convert a tuple state to a string representation
    return ''.join(''.join(row) for row in matrix)

def get_moves(state):
    # generate all possible moves for final state
    moves = []
    # Find blank position
    for i in range(3):
        for j in range(3):
            if state[i][j] == '0':
                blank_pos = (i, j)
                break

    # possible moves
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    for dx, dy in directions:
        new_x, new_y = blank_pos[0] + dx, blank_pos[1] + dy
        if 0 <= new_x < 3 and 0 <= new_y < 3:
            # Convert state to list for modification
            new_state = [list(row) for row in state]
            # Swap blank with adjacent tile
            new_state[blank_pos[0]][blank_pos[1]], new_state[new_x][new_y] = \
                new_state[new_x][new_y], new_state[blank_pos[0]][blank_pos[1]]
            # Convert back to tuple and add to moves
            moves.append(tuple(tuple(row) for row in new_state))
    return moves

def dfs(start_state, goal_state):
    # Perform Depth-First Search (DFS) to find a solution path
    stack = [(start_state, [start_state])]
    visited = {start_state}

    while stack:
        current_state, path = stack.pop()

        if current_state == goal_state:
            return path

        for next_state in get_moves(current_state):
            if next_state not in visited:
                visited.add(next_state)
                stack.append((next_state, path + [next_state]))

    return None

def main():
    """Main function to take input and execute the DFS algorithm."""
    start_state = input("Enter start State: ")
    goal_state = input("Enter goal State: ")

    start_tuple = state_to_tuple(start_state)
    goal_tuple = state_to_tuple(goal_state)

    print("-----------------")
    print("DFS Algorithm")
    print("-----------------")

    start_time = time.time()
    solution_path = dfs(start_tuple, goal_tuple)
    end_time = time.time()

    if solution_path:
        print("Time taken:", end_time - start_time, "seconds")
        print("Path Cost:", len(solution_path) - 1)
        print("No of Node Visited:", len(solution_path))
        print("-----------------")

        for state in solution_path:
            for row in state:
                print(' '.join(row))
            print("------")
    else:
        print("No solution found.")

if __name__ == "__main__":
    main()